#!/bin/bash
#
# Comprehensive Security Vulnerability Scanner
# Detects OWASP Top 10 and Rust-specific security issues
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
REPORTS_DIR="$PROJECT_ROOT/security-vulnerability-reports"

# Create reports directory
mkdir -p "$REPORTS_DIR"

echo -e "${BLUE}üîç Starting Comprehensive Security Vulnerability Scan${NC}"
echo "=================================================="

# Function to print section headers
print_section() {
    echo -e "\n${BLUE}>>> $1${NC}"
    echo "----------------------------------------"
}

# Function to check for critical patterns
check_critical_patterns() {
    print_section "Critical Security Pattern Analysis"
    
    local critical_issues=0
    local report_file="$REPORTS_DIR/critical-patterns-$(date +%Y%m%d-%H%M%S).txt"
    
    echo "Scanning for critical security anti-patterns..." > "$report_file"
    echo "Scan Date: $(date)" >> "$report_file"
    echo "========================================" >> "$report_file"
    
    # 1. Hardcoded Secrets
    echo -e "\n${YELLOW}Checking for hardcoded secrets...${NC}"
    if grep -r "fallback.*secret\|secret.*fallback\|default.*secret" --include="*.rs" "$PROJECT_ROOT" | grep -v target | grep -v ".git"; then
        echo "‚ùå CRITICAL: Hardcoded secret fallbacks detected" | tee -a "$report_file"
        critical_issues=$((critical_issues + 1))
    else
        echo "‚úÖ No hardcoded secret fallbacks found"
    fi
    
    # 2. Demo/Test Users in Production Code
    echo -e "\n${YELLOW}Checking for demo/test users...${NC}"
    if grep -r "demo.*user\|test.*user\|admin.*123" --include="*.rs" "$PROJECT_ROOT/auth-service/src" | grep -v test; then
        echo "‚ùå CRITICAL: Demo/test users in production code" | tee -a "$report_file"
        critical_issues=$((critical_issues + 1))
    else
        echo "‚úÖ No demo users in production code"
    fi
    
    # 3. Panic in Security-Critical Code
    echo -e "\n${YELLOW}Checking for panic conditions...${NC}"
    if grep -r "\.unwrap()\|\.expect(" --include="*.rs" "$PROJECT_ROOT/auth-service/src" | grep -E "(jwt|auth|crypto|security|csrf)"; then
        echo "‚ùå CRITICAL: Panic conditions in security code" | tee -a "$report_file"
        critical_issues=$((critical_issues + 1))
    else
        echo "‚úÖ No panic conditions in security code"
    fi
    
    # 4. Unsafe Code Without Documentation
    echo -e "\n${YELLOW}Checking for undocumented unsafe code...${NC}"
    unsafe_count=$(grep -r "unsafe" --include="*.rs" "$PROJECT_ROOT" | grep -v "# Safety" | wc -l)
    if [ "$unsafe_count" -gt 0 ]; then
        echo "‚ùå CRITICAL: $unsafe_count unsafe blocks without safety documentation" | tee -a "$report_file"
        grep -r "unsafe" --include="*.rs" "$PROJECT_ROOT" | grep -v "# Safety" | head -10 >> "$report_file"
        critical_issues=$((critical_issues + 1))
    else
        echo "‚úÖ All unsafe blocks properly documented"
    fi
    
    # 5. Weak Cryptographic Defaults
    echo -e "\n${YELLOW}Checking for weak crypto...${NC}"
    if grep -r -i "md5\|sha1\|des\|rc4" --include="*.rs" "$PROJECT_ROOT" | grep -v test | grep -v comment; then
        echo "‚ùå HIGH: Weak cryptographic algorithms detected" | tee -a "$report_file"
        critical_issues=$((critical_issues + 1))
    else
        echo "‚úÖ No weak cryptographic algorithms found"
    fi
    
    echo "Critical issues found: $critical_issues" >> "$report_file"
    echo -e "\n${RED}Critical issues detected: $critical_issues${NC}"
    
    if [ $critical_issues -gt 0 ]; then
        echo -e "${RED}‚ö†Ô∏è  SECURITY ALERT: Critical vulnerabilities found!${NC}"
        echo "Report saved to: $report_file"
        return 1
    fi
    
    return 0
}

# Function to check OWASP Top 10 vulnerabilities
check_owasp_top10() {
    print_section "OWASP Top 10 2021 Vulnerability Scan"
    
    local owasp_file="$REPORTS_DIR/owasp-scan-$(date +%Y%m%d-%H%M%S).json"
    
    cat > "$owasp_file" << EOF
{
  "scan_date": "$(date -Iseconds)",
  "owasp_categories": {
EOF
    
    # A01 - Broken Access Control
    echo -e "\n${YELLOW}A01 - Checking Access Control...${NC}"
    access_issues=0
    
    # Check for authorization bypasses
    if grep -r "admin.*bypass\|skip.*auth\|disable.*auth" --include="*.rs" "$PROJECT_ROOT"; then
        access_issues=$((access_issues + 1))
    fi
    
    # Check for missing authorization checks
    if grep -r "TODO.*auth\|FIXME.*auth" --include="*.rs" "$PROJECT_ROOT"; then
        access_issues=$((access_issues + 1))
    fi
    
    echo "    \"A01_broken_access_control\": { \"issues\": $access_issues, \"severity\": \"high\" }," >> "$owasp_file"
    
    # A02 - Cryptographic Failures
    echo -e "\n${YELLOW}A02 - Checking Cryptographic Failures...${NC}"
    crypto_issues=0
    
    # Check for weak random number generation
    if grep -r "rand::thread_rng\|std::collections::hash_map::DefaultHasher" --include="*.rs" "$PROJECT_ROOT"; then
        crypto_issues=$((crypto_issues + 1))
    fi
    
    # Check for hardcoded keys/secrets
    if grep -r -E "(secret|key|password).*=.*[\"'][^\"']{10,}[\"']" --include="*.rs" "$PROJECT_ROOT" | grep -v test; then
        crypto_issues=$((crypto_issues + 1))
    fi
    
    echo "    \"A02_cryptographic_failures\": { \"issues\": $crypto_issues, \"severity\": \"critical\" }," >> "$owasp_file"
    
    # A03 - Injection
    echo -e "\n${YELLOW}A03 - Checking Injection Vulnerabilities...${NC}"
    injection_issues=0
    
    # Check for potential SQL injection (even with sqlx, dynamic queries can be risky)
    if grep -r "format!\|concat!" --include="*.rs" "$PROJECT_ROOT" | grep -i "select\|insert\|update\|delete"; then
        injection_issues=$((injection_issues + 1))
    fi
    
    # Check for command injection
    if grep -r "Command::new\|std::process" --include="*.rs" "$PROJECT_ROOT" | grep -E "format!\|concat!"; then
        injection_issues=$((injection_issues + 1))
    fi
    
    echo "    \"A03_injection\": { \"issues\": $injection_issues, \"severity\": \"high\" }," >> "$owasp_file"
    
    # A07 - Identification and Authentication Failures
    echo -e "\n${YELLOW}A07 - Checking Authentication Failures...${NC}"
    auth_issues=0
    
    # Check for weak session management
    if grep -r "session.*=\|cookie.*=" --include="*.rs" "$PROJECT_ROOT" | grep -v "secure\|httponly"; then
        auth_issues=$((auth_issues + 1))
    fi
    
    echo "    \"A07_auth_failures\": { \"issues\": $auth_issues, \"severity\": \"critical\" }," >> "$owasp_file"
    
    # Close JSON
    echo "    \"scan_complete\": true" >> "$owasp_file"
    echo "  }" >> "$owasp_file"
    echo "}" >> "$owasp_file"
    
    echo "OWASP scan results saved to: $owasp_file"
}

# Function to check Rust-specific security issues
check_rust_specific() {
    print_section "Rust-Specific Security Issues"
    
    local rust_issues=0
    
    # Integer overflow checks
    echo -e "\n${YELLOW}Checking for integer overflow risks...${NC}"
    if grep -r "as u\|as i" --include="*.rs" "$PROJECT_ROOT" | grep -E "\+ |\* |\- " | head -5; then
        echo "‚ö†Ô∏è  Potential integer overflow in type casting"
        rust_issues=$((rust_issues + 1))
    fi
    
    # Deserialization vulnerabilities
    echo -e "\n${YELLOW}Checking for unsafe deserialization...${NC}"
    if grep -r "serde.*from_str\|bincode::deserialize" --include="*.rs" "$PROJECT_ROOT" | grep -v test; then
        echo "‚ö†Ô∏è  Deserialization from untrusted sources detected"
        rust_issues=$((rust_issues + 1))
    fi
    
    # Memory safety in concurrent code
    echo -e "\n${YELLOW}Checking for memory safety issues...${NC}"
    if grep -r "Arc<Mutex<\|Rc<RefCell<" --include="*.rs" "$PROJECT_ROOT" | grep -E "clone\(\)\.\|\.lock\(\)\." | head -5; then
        echo "‚ö†Ô∏è  Potential deadlock or race condition patterns"
        rust_issues=$((rust_issues + 1))
    fi
    
    echo "Rust-specific issues found: $rust_issues"
    return $rust_issues
}

# Function to generate security recommendations
generate_recommendations() {
    print_section "Security Recommendations"
    
    local rec_file="$REPORTS_DIR/security-recommendations-$(date +%Y%m%d).md"
    
    cat > "$rec_file" << 'EOF'
# Security Vulnerability Remediation Plan

## Immediate Actions Required (P0 - Critical)

### 1. Fix Authentication Bypass Vulnerabilities
- [ ] Remove all hardcoded secrets and demo users
- [ ] Implement proper environment variable validation
- [ ] Add authentication checks to all protected endpoints

### 2. Eliminate Panic Conditions
- [ ] Replace all `.unwrap()` calls in security code with proper error handling
- [ ] Add graceful degradation for crypto failures
- [ ] Implement proper error logging without information disclosure

### 3. Secure Cryptographic Implementation
- [ ] Remove weak cryptographic fallbacks
- [ ] Use secure random number generation throughout
- [ ] Implement proper key rotation and management

## Short-term Improvements (P1 - High Priority)

### 1. Input Validation and Sanitization
```rust
// Implement comprehensive input validation
pub fn validate_user_input(input: &str) -> Result<String, ValidationError> {
    if input.len() > MAX_INPUT_LENGTH {
        return Err(ValidationError::TooLong);
    }
    
    if input.chars().any(|c| !c.is_alphanumeric() && !c.is_whitespace()) {
        return Err(ValidationError::InvalidCharacters);
    }
    
    Ok(input.to_string())
}
```

### 2. Security Headers Implementation
```rust
// Add comprehensive security headers
fn add_security_headers(response: &mut Response) {
    response.headers_mut().insert("Strict-Transport-Security", 
        HeaderValue::from_static("max-age=31536000; includeSubDomains"));
    response.headers_mut().insert("X-Content-Type-Options", 
        HeaderValue::from_static("nosniff"));
    response.headers_mut().insert("X-Frame-Options", 
        HeaderValue::from_static("DENY"));
    response.headers_mut().insert("Content-Security-Policy", 
        HeaderValue::from_static("default-src 'self'"));
}
```

### 3. Audit Logging Enhancement
```rust
// Implement security event logging
#[derive(Debug)]
pub struct SecurityEvent {
    pub timestamp: DateTime<Utc>,
    pub event_type: SecurityEventType,
    pub user_id: Option<String>,
    pub ip_address: Option<IpAddr>,
    pub details: String,
}

pub fn log_security_event(event: SecurityEvent) {
    tracing::warn!(
        target: "security_audit",
        timestamp = %event.timestamp,
        event_type = ?event.event_type,
        user_id = ?event.user_id,
        ip_address = ?event.ip_address,
        "Security event: {}", event.details
    );
}
```

## Long-term Security Improvements

### 1. Automated Security Testing
- [ ] Integrate SAST tools in CI/CD pipeline
- [ ] Add dependency vulnerability scanning
- [ ] Implement runtime security monitoring

### 2. Security Architecture Review
- [ ] Implement proper secret management
- [ ] Add comprehensive rate limiting
- [ ] Implement proper session management

### 3. Compliance and Monitoring
- [ ] Add security metrics collection
- [ ] Implement incident response automation
- [ ] Regular security architecture reviews

EOF

    echo "Security recommendations saved to: $rec_file"
}

# Main execution
main() {
    echo "Project root: $PROJECT_ROOT"
    echo "Reports directory: $REPORTS_DIR"
    
    cd "$PROJECT_ROOT"
    
    local exit_code=0
    
    # Run all security checks
    if ! check_critical_patterns; then
        exit_code=1
    fi
    
    check_owasp_top10
    
    if ! check_rust_specific; then
        exit_code=1
    fi
    
    generate_recommendations
    
    # Summary
    echo -e "\n${BLUE}üîí Security Scan Summary${NC}"
    echo "==============================="
    
    if [ $exit_code -eq 0 ]; then
        echo -e "${GREEN}‚úÖ No critical security vulnerabilities detected${NC}"
        echo -e "${GREEN}üìä Review medium and low priority issues in reports${NC}"
    else
        echo -e "${RED}‚ùå CRITICAL security vulnerabilities found!${NC}"
        echo -e "${RED}üö® DO NOT DEPLOY until issues are resolved${NC}"
    fi
    
    echo -e "\n${BLUE}üìÅ Reports generated in: $REPORTS_DIR${NC}"
    ls -la "$REPORTS_DIR"
    
    exit $exit_code
}

# Run main function with all arguments
main "$@"