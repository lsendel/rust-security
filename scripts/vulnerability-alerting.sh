#!/bin/bash
# Vulnerability Alerting and Reporting System
# Provides comprehensive vulnerability monitoring and alerting

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
ALERTS_DIR="$PROJECT_ROOT/target/vulnerability-alerts"
CONFIG_DIR="$PROJECT_ROOT/.security"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Create directories
mkdir -p "$ALERTS_DIR" "$CONFIG_DIR"

# Initialize alerting configuration
init_alerting_config() {
    local config_file="$CONFIG_DIR/alerting-config.toml"
    
    if [[ ! -f "$config_file" ]]; then
        cat > "$config_file" << 'EOF'
# Vulnerability Alerting Configuration
[alerting]
enabled = true
check_interval_hours = 6
severity_threshold = "medium"  # low, medium, high, critical
alert_channels = ["github_issues", "github_discussions"] # github_issues, github_discussions, slack, email

[severity_mapping]
critical = { priority = 1, notification = "immediate", escalation = true }
high = { priority = 2, notification = "within_hour", escalation = true }
medium = { priority = 3, notification = "within_day", escalation = false }
low = { priority = 4, notification = "weekly_summary", escalation = false }

[notification_templates]
critical = """
🚨 CRITICAL SECURITY VULNERABILITY DETECTED 🚨

**Vulnerability ID:** {vuln_id}
**Affected Package:** {package_name} {package_version}
**Severity:** {severity}
**CVSS Score:** {cvss_score}

**Description:** {description}

**Immediate Action Required:**
{mitigation}

**Detection Time:** {timestamp}
**Project:** {project_name}

@security-team @devops-team
"""

high = """
⚠️ HIGH SEVERITY VULNERABILITY DETECTED

**Vulnerability ID:** {vuln_id}
**Affected Package:** {package_name} {package_version}
**Severity:** {severity}

**Description:** {description}

**Recommended Actions:**
{mitigation}

**Detection Time:** {timestamp}

@security-team
"""

medium = """
📋 MEDIUM SEVERITY VULNERABILITY DETECTED

**Vulnerability ID:** {vuln_id}
**Affected Package:** {package_name} {package_version}
**Severity:** {severity}

**Description:** {description}

**Recommended Actions:**
{mitigation}

**Detection Time:** {timestamp}
"""

[exclusions]
# Vulnerabilities to ignore (with justification)
ignored_advisories = [
    # "RUSTSEC-2023-0001", # Reason: Not applicable to our use case
]

# Packages to exclude from alerting
ignored_packages = [
    # "example-dev-only-package",
]

[reporting]
daily_summary = true
weekly_report = true
monthly_trend_analysis = true
export_formats = ["json", "csv", "sarif"]

[integration]
github_token_env = "GITHUB_TOKEN"
slack_webhook_env = "SLACK_WEBHOOK_URL"
email_smtp_config = { enabled = false, host = "", port = 587, username_env = "", password_env = "" }
EOF
        log_info "Created alerting configuration: $config_file"
    fi
}

# Load configuration
load_config() {
    local config_file="$CONFIG_DIR/alerting-config.toml"
    
    if [[ ! -f "$config_file" ]]; then
        init_alerting_config
    fi
    
    # Export configuration for use in functions
    export CONFIG_FILE="$config_file"
}

# Parse TOML configuration (simplified - requires python3)
get_config_value() {
    local key="$1"
    local default="${2:-}"
    
    if command -v python3 &> /dev/null; then
        python3 << EOF
import toml
import sys

try:
    with open('$CONFIG_FILE', 'r') as f:
        config = toml.load(f)
    
    keys = '$key'.split('.')
    value = config
    for k in keys:
        value = value.get(k, {})
    
    if value == {}:
        print('$default')
    else:
        print(value)
except Exception:
    print('$default')
EOF
    else
        echo "$default"
    fi
}

# Check for new vulnerabilities
check_vulnerabilities() {
    log_info "Checking for new vulnerabilities..."
    
    local audit_file="$ALERTS_DIR/current-audit.json"
    local previous_audit_file="$ALERTS_DIR/previous-audit.json"
    
    # Move current audit to previous if it exists
    if [[ -f "$audit_file" ]]; then
        cp "$audit_file" "$previous_audit_file"
    fi
    
    # Run new audit
    if cargo audit --json > "$audit_file" 2>&1; then
        log_success "Vulnerability audit completed"
    else
        log_warning "Audit completed with findings"
    fi
    
    # Compare with previous audit to find new vulnerabilities
    local new_vulns=()
    
    if [[ -f "$previous_audit_file" ]] && command -v jq &> /dev/null; then
        # Find vulnerabilities that are in current but not in previous
        local current_ids
        local previous_ids
        
        current_ids=$(jq -r '.vulnerabilities.found[]?.advisory.id' "$audit_file" 2>/dev/null | sort)
        previous_ids=$(jq -r '.vulnerabilities.found[]?.advisory.id' "$previous_audit_file" 2>/dev/null | sort)
        
        while IFS= read -r vuln_id; do
            if [[ -n "$vuln_id" ]] && ! echo "$previous_ids" | grep -q "^$vuln_id$"; then
                new_vulns+=("$vuln_id")
            fi
        done <<< "$current_ids"
    else
        # First run - treat all vulnerabilities as new
        if command -v jq &> /dev/null; then
            while IFS= read -r vuln_id; do
                if [[ -n "$vuln_id" ]]; then
                    new_vulns+=("$vuln_id")
                fi
            done < <(jq -r '.vulnerabilities.found[]?.advisory.id' "$audit_file" 2>/dev/null)
        fi
    fi
    
    # Process new vulnerabilities
    local new_count=${#new_vulns[@]}
    
    if [[ $new_count -gt 0 ]]; then
        log_warning "Found $new_count new vulnerabilities"
        
        for vuln_id in "${new_vulns[@]}"; do
            process_vulnerability "$vuln_id" "$audit_file"
        done
    else
        log_success "No new vulnerabilities detected"
    fi
    
    # Generate summary
    generate_vulnerability_summary "$audit_file"
}

# Process individual vulnerability
process_vulnerability() {
    local vuln_id="$1"
    local audit_file="$2"
    
    log_info "Processing vulnerability: $vuln_id"
    
    if ! command -v jq &> /dev/null; then
        log_warning "jq not available, skipping vulnerability processing"
        return 0
    fi
    
    # Extract vulnerability details
    local vuln_data
    vuln_data=$(jq ".vulnerabilities.found[] | select(.advisory.id == \"$vuln_id\")" "$audit_file")
    
    if [[ -z "$vuln_data" ]]; then
        log_error "Vulnerability $vuln_id not found in audit data"
        return 1
    fi
    
    # Parse vulnerability information
    local package_name
    local package_version
    local severity
    local title
    local description
    local cvss_score
    local url
    
    package_name=$(echo "$vuln_data" | jq -r '.package.name')
    package_version=$(echo "$vuln_data" | jq -r '.package.version')
    severity=$(echo "$vuln_data" | jq -r '.advisory.severity // "unknown"')
    title=$(echo "$vuln_data" | jq -r '.advisory.title')
    description=$(echo "$vuln_data" | jq -r '.advisory.description')
    cvss_score=$(echo "$vuln_data" | jq -r '.advisory.cvss // "N/A"')
    url=$(echo "$vuln_data" | jq -r '.advisory.url')
    
    # Check if vulnerability should be ignored
    local ignored_advisories
    ignored_advisories=$(get_config_value "exclusions.ignored_advisories" "[]")
    
    if echo "$ignored_advisories" | grep -q "$vuln_id"; then
        log_info "Vulnerability $vuln_id is in ignore list, skipping"
        return 0
    fi
    
    # Check severity threshold
    local severity_threshold
    severity_threshold=$(get_config_value "alerting.severity_threshold" "medium")
    
    if ! should_alert_for_severity "$severity" "$severity_threshold"; then
        log_info "Vulnerability $vuln_id severity ($severity) below threshold ($severity_threshold)"
        return 0
    fi
    
    # Create vulnerability record
    local vuln_record_file="$ALERTS_DIR/vulnerabilities/${vuln_id}.json"
    mkdir -p "$(dirname "$vuln_record_file")"
    
    cat > "$vuln_record_file" << EOF
{
    "id": "$vuln_id",
    "package_name": "$package_name",
    "package_version": "$package_version",
    "severity": "$severity",
    "title": "$title",
    "description": "$description",
    "cvss_score": "$cvss_score",
    "url": "$url",
    "detection_time": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
    "status": "new",
    "alerts_sent": []
}
EOF
    
    # Send alerts
    send_vulnerability_alert "$vuln_id" "$vuln_record_file"
}

# Check if should alert for severity level
should_alert_for_severity() {
    local vuln_severity="$1"
    local threshold="$2"
    
    # Define severity levels (1 = highest, 4 = lowest)
    local -A severity_levels=(
        ["critical"]=1
        ["high"]=2
        ["medium"]=3
        ["low"]=4
    )
    
    local vuln_level=${severity_levels[$vuln_severity]:-4}
    local threshold_level=${severity_levels[$threshold]:-3}
    
    [[ $vuln_level -le $threshold_level ]]
}

# Send vulnerability alert
send_vulnerability_alert() {
    local vuln_id="$1"
    local vuln_record_file="$2"
    
    if ! command -v jq &> /dev/null; then
        log_warning "jq not available, cannot send structured alerts"
        return 0
    fi
    
    # Load vulnerability data
    local vuln_data
    vuln_data=$(cat "$vuln_record_file")
    
    local severity
    severity=$(echo "$vuln_data" | jq -r '.severity')
    
    # Get alert channels
    local alert_channels
    alert_channels=$(get_config_value "alerting.alert_channels" '["github_issues"]')
    
    # Send alerts to each configured channel
    if echo "$alert_channels" | grep -q "github_issues"; then
        send_github_issue_alert "$vuln_id" "$vuln_data"
    fi
    
    if echo "$alert_channels" | grep -q "github_discussions"; then
        send_github_discussion_alert "$vuln_id" "$vuln_data"
    fi
    
    if echo "$alert_channels" | grep -q "slack"; then
        send_slack_alert "$vuln_id" "$vuln_data"
    fi
    
    # Update vulnerability record with sent alerts
    local updated_data
    updated_data=$(echo "$vuln_data" | jq ".alerts_sent += [\"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"]")
    echo "$updated_data" > "$vuln_record_file"
}

# Send GitHub issue alert
send_github_issue_alert() {
    local vuln_id="$1"
    local vuln_data="$2"
    
    if [[ -z "${GITHUB_TOKEN:-}" ]]; then
        log_warning "GITHUB_TOKEN not set, cannot create GitHub issue"
        return 0
    fi
    
    log_info "Creating GitHub issue for vulnerability $vuln_id"
    
    local package_name
    local severity
    local title
    local description
    local cvss_score
    local url
    
    package_name=$(echo "$vuln_data" | jq -r '.package_name')
    severity=$(echo "$vuln_data" | jq -r '.severity')
    title=$(echo "$vuln_data" | jq -r '.title')
    description=$(echo "$vuln_data" | jq -r '.description')
    cvss_score=$(echo "$vuln_data" | jq -r '.cvss_score')
    url=$(echo "$vuln_data" | jq -r '.url')
    
    # Get template for severity
    local template
    template=$(get_config_value "notification_templates.$severity" "")
    
    if [[ -z "$template" ]]; then
        template="Security vulnerability detected: $vuln_id in $package_name"
    fi
    
    # Create issue body
    local issue_body
    issue_body=$(cat << EOF
$template

## Vulnerability Details

- **ID:** $vuln_id
- **Package:** $package_name
- **Severity:** $severity
- **CVSS Score:** $cvss_score
- **Advisory URL:** $url

## Description

$description

## Recommended Actions

1. Review the vulnerability details
2. Assess impact on our codebase
3. Plan remediation strategy
4. Update affected dependencies
5. Verify fixes with security tests

## Auto-generated

This issue was automatically created by the vulnerability monitoring system.
EOF
    )
    
    # Create GitHub issue using API
    if command -v curl &> /dev/null; then
        local repo_owner
        local repo_name
        
        # Extract repository information from git remote
        if git remote get-url origin &> /dev/null; then
            local remote_url
            remote_url=$(git remote get-url origin)
            repo_owner=$(echo "$remote_url" | sed -n 's/.*github\.com[:/]\([^/]*\)\/.*/\1/p')
            repo_name=$(echo "$remote_url" | sed -n 's/.*github\.com[:/][^/]*\/\([^/]*\)\.git$/\1/p')
            
            if [[ -n "$repo_owner" && -n "$repo_name" ]]; then
                curl -s -X POST \
                    -H "Authorization: token $GITHUB_TOKEN" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/$repo_owner/$repo_name/issues" \
                    -d "{
                        \"title\": \"Security Alert: $vuln_id in $package_name\",
                        \"body\": $(echo "$issue_body" | jq -Rs .),
                        \"labels\": [\"security\", \"vulnerability\", \"$severity\", \"automated\"]
                    }" > /dev/null
                
                log_success "GitHub issue created for $vuln_id"
            else
                log_warning "Could not determine GitHub repository information"
            fi
        fi
    fi
}

# Send GitHub discussion alert
send_github_discussion_alert() {
    local vuln_id="$1"
    local vuln_data="$2"
    
    log_info "GitHub discussions alert for $vuln_id (implementation depends on GraphQL API)"
}

# Send Slack alert
send_slack_alert() {
    local vuln_id="$1"
    local vuln_data="$2"
    
    if [[ -z "${SLACK_WEBHOOK_URL:-}" ]]; then
        log_warning "SLACK_WEBHOOK_URL not set, cannot send Slack alert"
        return 0
    fi
    
    log_info "Sending Slack alert for vulnerability $vuln_id"
    
    local package_name
    local severity
    local title
    
    package_name=$(echo "$vuln_data" | jq -r '.package_name')
    severity=$(echo "$vuln_data" | jq -r '.severity')
    title=$(echo "$vuln_data" | jq -r '.title')
    
    # Choose emoji based on severity
    local emoji
    case "$severity" in
        "critical") emoji="🚨" ;;
        "high") emoji="⚠️" ;;
        "medium") emoji="📋" ;;
        *) emoji="ℹ️" ;;
    esac
    
    local slack_payload
    slack_payload=$(cat << EOF
{
    "text": "$emoji Security Vulnerability Alert",
    "attachments": [
        {
            "color": "danger",
            "fields": [
                {
                    "title": "Vulnerability ID",
                    "value": "$vuln_id",
                    "short": true
                },
                {
                    "title": "Package",
                    "value": "$package_name",
                    "short": true
                },
                {
                    "title": "Severity",
                    "value": "$severity",
                    "short": true
                },
                {
                    "title": "Title",
                    "value": "$title",
                    "short": false
                }
            ],
            "footer": "Rust Security Platform - Vulnerability Monitor",
            "ts": $(date +%s)
        }
    ]
}
EOF
    )
    
    curl -X POST -H 'Content-type: application/json' \
         --data "$slack_payload" \
         "$SLACK_WEBHOOK_URL" &> /dev/null
    
    log_success "Slack alert sent for $vuln_id"
}

# Generate vulnerability summary
generate_vulnerability_summary() {
    local audit_file="$1"
    local summary_file="$ALERTS_DIR/vulnerability-summary.md"
    local timestamp
    timestamp=$(date)
    
    log_info "Generating vulnerability summary..."
    
    cat > "$summary_file" << EOF
# Vulnerability Summary Report

**Generated:** $timestamp
**Project:** Rust Security Platform

## Current Status

EOF
    
    if command -v jq &> /dev/null && [[ -f "$audit_file" ]]; then
        local total_vulns
        local critical_vulns
        local high_vulns
        local medium_vulns
        local low_vulns
        
        total_vulns=$(jq '.vulnerabilities.found | length' "$audit_file" 2>/dev/null || echo "0")
        critical_vulns=$(jq '[.vulnerabilities.found[] | select(.advisory.severity == "critical")] | length' "$audit_file" 2>/dev/null || echo "0")
        high_vulns=$(jq '[.vulnerabilities.found[] | select(.advisory.severity == "high")] | length' "$audit_file" 2>/dev/null || echo "0")
        medium_vulns=$(jq '[.vulnerabilities.found[] | select(.advisory.severity == "medium")] | length' "$audit_file" 2>/dev/null || echo "0")
        low_vulns=$(jq '[.vulnerabilities.found[] | select(.advisory.severity == "low")] | length' "$audit_file" 2>/dev/null || echo "0")
        
        cat >> "$summary_file" << EOF
- **Total Vulnerabilities:** $total_vulns
- **Critical:** $critical_vulns
- **High:** $high_vulns
- **Medium:** $medium_vulns
- **Low:** $low_vulns

## Vulnerability Details

EOF
        
        if [[ $total_vulns -gt 0 ]]; then
            jq -r '.vulnerabilities.found[] | 
                   "### \(.advisory.id): \(.advisory.title)
                   
                   - **Package:** \(.package.name) \(.package.version)
                   - **Severity:** \(.advisory.severity // "unknown")
                   - **CVSS:** \(.advisory.cvss // "N/A")
                   - **URL:** \(.advisory.url)
                   
                   \(.advisory.description)
                   
                   "' "$audit_file" >> "$summary_file"
        else
            echo "No vulnerabilities found." >> "$summary_file"
        fi
    else
        echo "Unable to parse audit results." >> "$summary_file"
    fi
    
    cat >> "$summary_file" << EOF

## Monitoring Status

- **Last Check:** $timestamp
- **Next Check:** Scheduled based on configuration
- **Alert Channels:** Configured in alerting-config.toml

---
*This summary is automatically generated by the vulnerability monitoring system.*
EOF
    
    log_success "Vulnerability summary generated: $summary_file"
}

# Generate trend analysis
generate_trend_analysis() {
    log_info "Generating vulnerability trend analysis..."
    
    local trend_file="$ALERTS_DIR/vulnerability-trends.json"
    local current_date
    current_date=$(date +"%Y-%m-%d")
    
    # Initialize trends file if it doesn't exist
    if [[ ! -f "$trend_file" ]]; then
        echo '{"daily_counts": {}, "vulnerability_history": []}' > "$trend_file"
    fi
    
    if command -v jq &> /dev/null; then
        local current_count
        current_count=$(jq '.vulnerabilities.found | length' "$ALERTS_DIR/current-audit.json" 2>/dev/null || echo "0")
        
        # Update trends data
        local updated_trends
        updated_trends=$(jq ".daily_counts[\"$current_date\"] = $current_count" "$trend_file")
        echo "$updated_trends" > "$trend_file"
        
        log_success "Trend analysis updated"
    fi
}

# Export vulnerability data
export_vulnerability_data() {
    local format="${1:-json}"
    local export_file="$ALERTS_DIR/vulnerability-export-$(date +%Y%m%d).$format"
    
    log_info "Exporting vulnerability data as $format..."
    
    case "$format" in
        "json")
            if [[ -f "$ALERTS_DIR/current-audit.json" ]]; then
                cp "$ALERTS_DIR/current-audit.json" "$export_file"
            fi
            ;;
        "csv")
            if command -v jq &> /dev/null && [[ -f "$ALERTS_DIR/current-audit.json" ]]; then
                echo "vuln_id,package_name,package_version,severity,title,cvss_score" > "$export_file"
                jq -r '.vulnerabilities.found[] | 
                       [.advisory.id, .package.name, .package.version, (.advisory.severity // "unknown"), .advisory.title, (.advisory.cvss // "N/A")] | 
                       @csv' "$ALERTS_DIR/current-audit.json" >> "$export_file"
            fi
            ;;
        "sarif")
            # Convert to SARIF format for security tools integration
            if command -v jq &> /dev/null && [[ -f "$ALERTS_DIR/current-audit.json" ]]; then
                jq '{
                    "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0.json",
                    "version": "2.1.0",
                    "runs": [{
                        "tool": {
                            "driver": {
                                "name": "cargo-audit",
                                "version": "0.18.0"
                            }
                        },
                        "results": [.vulnerabilities.found[] | {
                            "ruleId": .advisory.id,
                            "message": {"text": .advisory.title},
                            "level": (if .advisory.severity == "critical" then "error" 
                                     elif .advisory.severity == "high" then "error"
                                     elif .advisory.severity == "medium" then "warning"
                                     else "note" end),
                            "locations": [{
                                "physicalLocation": {
                                    "artifactLocation": {"uri": "Cargo.lock"}
                                }
                            }]
                        }]
                    }]
                }' "$ALERTS_DIR/current-audit.json" > "$export_file"
            fi
            ;;
    esac
    
    log_success "Vulnerability data exported to: $export_file"
}

# Usage information
usage() {
    cat << EOF
Vulnerability Alerting System

Usage: $0 <command> [arguments]

Commands:
    init                          Initialize alerting configuration
    check                        Check for new vulnerabilities
    summary                      Generate vulnerability summary
    trends                       Generate trend analysis
    export <format>              Export vulnerability data (json, csv, sarif)
    test-alert <vuln_id>         Test alert system with specific vulnerability
    monitor                      Run continuous monitoring (daemon mode)

Examples:
    $0 init
    $0 check
    $0 summary
    $0 export csv
    $0 test-alert RUSTSEC-2023-0001

Environment Variables:
    GITHUB_TOKEN                 GitHub API token for issue creation
    SLACK_WEBHOOK_URL           Slack webhook URL for notifications

EOF
}

# Monitor mode (continuous checking)
monitor_mode() {
    log_info "Starting vulnerability monitoring daemon..."
    
    local check_interval
    check_interval=$(get_config_value "alerting.check_interval_hours" "6")
    
    log_info "Monitoring interval: $check_interval hours"
    
    while true; do
        log_info "Running scheduled vulnerability check..."
        check_vulnerabilities
        generate_trend_analysis
        
        log_info "Next check in $check_interval hours"
        sleep $((check_interval * 3600))
    done
}

# Test alert functionality
test_alert() {
    local vuln_id="${1:-RUSTSEC-TEST-0001}"
    
    log_info "Testing alert system with vulnerability: $vuln_id"
    
    # Create test vulnerability record
    local test_vuln_file="$ALERTS_DIR/test-vulnerability.json"
    
    cat > "$test_vuln_file" << EOF
{
    "id": "$vuln_id",
    "package_name": "test-package",
    "package_version": "1.0.0",
    "severity": "high",
    "title": "Test Vulnerability Alert",
    "description": "This is a test vulnerability used to verify the alerting system.",
    "cvss_score": "7.5",
    "url": "https://example.com/advisory",
    "detection_time": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
    "status": "test",
    "alerts_sent": []
}
EOF
    
    # Send test alert
    local vuln_data
    vuln_data=$(cat "$test_vuln_file")
    
    send_vulnerability_alert "$vuln_id" "$test_vuln_file"
    
    # Clean up test file
    rm -f "$test_vuln_file"
    
    log_success "Test alert completed"
}

# Main execution
main() {
    cd "$PROJECT_ROOT"
    load_config
    
    case "${1:-}" in
        "init")
            init_alerting_config
            ;;
        "check")
            check_vulnerabilities
            ;;
        "summary")
            if [[ -f "$ALERTS_DIR/current-audit.json" ]]; then
                generate_vulnerability_summary "$ALERTS_DIR/current-audit.json"
            else
                log_error "No audit data found. Run 'check' first."
                exit 1
            fi
            ;;
        "trends")
            generate_trend_analysis
            ;;
        "export")
            export_vulnerability_data "${2:-json}"
            ;;
        "test-alert")
            test_alert "${2:-}"
            ;;
        "monitor")
            monitor_mode
            ;;
        *)
            usage
            exit 1
            ;;
    esac
}

main "$@"