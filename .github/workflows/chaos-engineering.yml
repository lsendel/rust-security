name: Chaos Engineering and Security Testing

on:
  schedule:
    - cron: '0 2 * * 1-5'  # Weekdays at 2 AM UTC
  workflow_dispatch:
    inputs:
      experiment_type:
        description: 'Type of chaos experiment to run'
        required: false
        default: 'network-latency'
        type: choice
        options:
          - network-latency
          - pod-kill
          - memory-stress
          - cpu-stress
          - io-delay
          - dns-failure
          - security-tests
          - full-suite
      target_environment:
        description: 'Target environment'
        required: false
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - never-production
      duration_minutes:
        description: 'Experiment duration (minutes)'
        required: false
        default: '5'
        type: string

env:
  CHAOS_MESH_VERSION: v2.6.0
  KUBECTL_VERSION: v1.28.0
  KUBECONFIG: ${{ github.workspace }}/kubeconfig
  EXPERIMENT_DURATION: ${{ github.event.inputs.duration_minutes || '5' }}
  TARGET_ENV: ${{ github.event.inputs.target_environment || 'development' }}

jobs:
  pre-flight-checks:
    name: Pre-flight Safety Checks
    runs-on: ubuntu-latest
    outputs:
      can_proceed: ${{ steps.safety_check.outputs.can_proceed }}
      baseline_metrics: ${{ steps.baseline.outputs.metrics }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Verify cluster connectivity
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Check cluster health
        id: cluster_health
        run: |
          # Check node health
          UNHEALTHY_NODES=$(kubectl get nodes --no-headers | grep -c "NotReady" || echo "0")
          if [ "$UNHEALTHY_NODES" -gt 0 ]; then
            echo "âŒ Found $UNHEALTHY_NODES unhealthy nodes"
            exit 1
          fi
          
          # Check system pods
          SYSTEM_PODS_NOT_READY=$(kubectl get pods -n kube-system --no-headers | grep -v "Running\|Completed" | wc -l)
          if [ "$SYSTEM_PODS_NOT_READY" -gt 0 ]; then
            echo "âŒ Found $SYSTEM_PODS_NOT_READY system pods not ready"
            kubectl get pods -n kube-system --no-headers | grep -v "Running\|Completed"
            exit 1
          fi
          
          echo "âœ… Cluster health check passed"

      - name: Check target environment health
        run: |
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          # Check if target namespace exists
          if ! kubectl get namespace "$TARGET_NAMESPACE" >/dev/null 2>&1; then
            echo "âŒ Target namespace $TARGET_NAMESPACE does not exist"
            exit 1
          fi
          
          # Check application pods health
          NOT_READY_PODS=$(kubectl get pods -n "$TARGET_NAMESPACE" --no-headers | grep -v "Running\|Completed" | wc -l)
          if [ "$NOT_READY_PODS" -gt 0 ]; then
            echo "âŒ Found $NOT_READY_PODS pods not ready in $TARGET_NAMESPACE"
            kubectl get pods -n "$TARGET_NAMESPACE"
            exit 1
          fi
          
          echo "âœ… Target environment health check passed"

      - name: Check for active incidents
        run: |
          # Check Prometheus alerts (if available)
          if kubectl get service prometheus -n monitoring >/dev/null 2>&1; then
            echo "ðŸ“Š Checking Prometheus alerts..."
            
            # Port forward to Prometheus
            kubectl port-forward -n monitoring svc/prometheus 9090:9090 &
            PROMETHEUS_PID=$!
            sleep 5
            
            # Query for critical alerts
            CRITICAL_ALERTS=$(curl -s "http://localhost:9090/api/v1/alerts" | jq -r '.data[] | select(.labels.severity == "critical") | .labels.alertname' | wc -l || echo "0")
            
            kill $PROMETHEUS_PID 2>/dev/null || true
            
            if [ "$CRITICAL_ALERTS" -gt 0 ]; then
              echo "âŒ Found $CRITICAL_ALERTS critical alerts active"
              exit 1
            fi
          fi
          
          echo "âœ… No active critical incidents found"

      - name: Collect baseline metrics
        id: baseline
        run: |
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          # Collect baseline metrics
          echo "ðŸ“Š Collecting baseline metrics..."
          
          # Service health metrics
          AUTH_PODS=$(kubectl get pods -n "$TARGET_NAMESPACE" -l app=auth-service --no-headers | grep "Running" | wc -l)
          POLICY_PODS=$(kubectl get pods -n "$TARGET_NAMESPACE" -l app=policy-service --no-headers | grep "Running" | wc -l)
          REDIS_PODS=$(kubectl get pods -n "$TARGET_NAMESPACE" -l app=redis --no-headers | grep "Running" | wc -l)
          
          # Resource utilization (simplified)
          CPU_USAGE=$(kubectl top nodes --no-headers 2>/dev/null | awk '{sum += $3} END {print sum/NR}' || echo "0")
          MEMORY_USAGE=$(kubectl top nodes --no-headers 2>/dev/null | awk '{sum += $5} END {print sum/NR}' || echo "0")
          
          BASELINE_METRICS="{
            \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
            \"auth_service_pods\": $AUTH_PODS,
            \"policy_service_pods\": $POLICY_PODS,
            \"redis_pods\": $REDIS_PODS,
            \"cpu_usage_percent\": \"$CPU_USAGE\",
            \"memory_usage_percent\": \"$MEMORY_USAGE\"
          }"
          
          echo "metrics=$BASELINE_METRICS" >> $GITHUB_OUTPUT
          echo "âœ… Baseline metrics collected"

      - name: Safety check decision
        id: safety_check
        run: |
          # Check if it's production (should never be)
          if [[ "${{ env.TARGET_ENV }}" == "production" ]]; then
            echo "âŒ NEVER run chaos experiments in production!"
            echo "can_proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check if it's a weekend (for automated runs)
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            DAY_OF_WEEK=$(date +%u)
            if [[ $DAY_OF_WEEK -gt 5 ]]; then
              echo "â¸ï¸ Skipping weekend automated chaos experiments"
              echo "can_proceed=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Check if business hours (9 AM - 6 PM UTC)
          HOUR=$(date -u +%H)
          if [[ "${{ github.event_name }}" == "schedule" && ($HOUR -ge 9 && $HOUR -le 18) ]]; then
            echo "â¸ï¸ Skipping chaos experiments during business hours"
            echo "can_proceed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "âœ… All safety checks passed"
          echo "can_proceed=true" >> $GITHUB_OUTPUT

  install-chaos-mesh:
    name: Install Chaos Mesh
    runs-on: ubuntu-latest
    needs: pre-flight-checks
    if: needs.pre-flight-checks.outputs.can_proceed == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Check if Chaos Mesh is installed
        id: check_chaos_mesh
        run: |
          if kubectl get namespace chaos-engineering >/dev/null 2>&1; then
            echo "installed=true" >> $GITHUB_OUTPUT
          else
            echo "installed=false" >> $GITHUB_OUTPUT
          fi

      - name: Install Chaos Mesh
        if: steps.check_chaos_mesh.outputs.installed == 'false'
        run: |
          # Create chaos-engineering namespace
          kubectl apply -f k8s/chaos-mesh/namespace.yaml
          
          # Add Chaos Mesh Helm repository
          helm repo add chaos-mesh https://charts.chaos-mesh.org
          helm repo update
          
          # Install Chaos Mesh with security configurations
          helm install chaos-mesh chaos-mesh/chaos-mesh \
            --namespace chaos-engineering \
            --version ${{ env.CHAOS_MESH_VERSION }} \
            --set controllerManager.replicaCount=1 \
            --set dashboard.securityMode=true \
            --set chaosDaemon.privileged=false \
            --set chaosDaemon.hostNetwork=false \
            --set webhook.certManager.enabled=false \
            --set dashboard.service.type=ClusterIP \
            --wait --timeout=300s
          
          echo "âœ… Chaos Mesh installed successfully"

      - name: Verify Chaos Mesh installation
        run: |
          # Wait for Chaos Mesh pods to be ready
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=chaos-mesh -n chaos-engineering --timeout=300s
          
          # Check Chaos Mesh components
          kubectl get pods -n chaos-engineering
          kubectl get crd | grep chaos-mesh.org
          
          echo "âœ… Chaos Mesh verification completed"

      - name: Apply chaos experiment definitions
        run: |
          # Apply experiment definitions
          kubectl apply -f chaos-engineering/experiments/
          
          # Apply safety configuration
          kubectl apply -f k8s/chaos-mesh/
          
          echo "âœ… Chaos experiment definitions applied"

  run-network-chaos:
    name: Run Network Chaos Experiments
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, install-chaos-mesh]
    if: |
      needs.pre-flight-checks.outputs.can_proceed == 'true' && 
      (github.event.inputs.experiment_type == 'network-latency' || 
       github.event.inputs.experiment_type == 'full-suite' ||
       github.event_name == 'schedule')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Execute network latency experiment
        run: |
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          # Create network chaos experiment
          cat <<EOF | kubectl apply -f -
          apiVersion: chaos-mesh.org/v1alpha1
          kind: NetworkChaos
          metadata:
            name: ci-network-latency-$(date +%s)
            namespace: chaos-engineering
          spec:
            action: delay
            mode: one
            selector:
              namespaces:
                - $TARGET_NAMESPACE
              labelSelectors:
                app: auth-service
            delay:
              latency: 200ms
              correlation: "25"
              jitter: 10ms
            duration: ${EXPERIMENT_DURATION}m
          EOF
          
          echo "ðŸ§ª Network latency experiment started"

      - name: Monitor experiment progress
        timeout-minutes: 10
        run: |
          EXPERIMENT_NAME=$(kubectl get networkchaos -n chaos-engineering --sort-by=.metadata.creationTimestamp | tail -1 | awk '{print $1}')
          
          echo "Monitoring experiment: $EXPERIMENT_NAME"
          
          for i in {1..20}; do
            STATUS=$(kubectl get networkchaos -n chaos-engineering "$EXPERIMENT_NAME" -o jsonpath='{.status.conditions[-1].type}' 2>/dev/null || echo "Unknown")
            echo "Experiment status: $STATUS"
            
            if [[ "$STATUS" == "AllInjected" ]]; then
              echo "âœ… Experiment is actively injecting faults"
              break
            elif [[ "$STATUS" == "AllRecovered" ]]; then
              echo "âœ… Experiment completed successfully"
              break
            fi
            
            sleep 15
          done

      - name: Collect experiment metrics
        run: |
          # Collect metrics during and after experiment
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          echo "ðŸ“Š Collecting experiment metrics..."
          
          # Check service health during experiment
          kubectl get pods -n "$TARGET_NAMESPACE" -l app=auth-service
          
          # Check if services are responding (basic check)
          AUTH_SERVICE_IP=$(kubectl get service -n "$TARGET_NAMESPACE" auth-service -o jsonpath='{.spec.clusterIP}' 2>/dev/null || echo "")
          if [[ -n "$AUTH_SERVICE_IP" ]]; then
            kubectl run curl-test --rm -i --restart=Never --image=curlimages/curl -- curl -m 10 "http://$AUTH_SERVICE_IP:8080/health" || echo "Service unreachable during experiment"
          fi
          
          echo "âœ… Metrics collection completed"

  run-pod-chaos:
    name: Run Pod Chaos Experiments  
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, install-chaos-mesh]
    if: |
      needs.pre-flight-checks.outputs.can_proceed == 'true' && 
      (github.event.inputs.experiment_type == 'pod-kill' || 
       github.event.inputs.experiment_type == 'full-suite' ||
       github.event_name == 'schedule')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Execute pod kill experiment
        run: |
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          # Ensure we have enough replicas before killing pods
          REPLICA_COUNT=$(kubectl get deployment -n "$TARGET_NAMESPACE" auth-service -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "1")
          if [[ "$REPLICA_COUNT" -lt 2 ]]; then
            echo "ðŸ”§ Scaling auth-service to 2 replicas for pod kill experiment"
            kubectl scale deployment -n "$TARGET_NAMESPACE" auth-service --replicas=2
            kubectl wait --for=condition=available deployment/auth-service -n "$TARGET_NAMESPACE" --timeout=120s
          fi
          
          # Create pod chaos experiment
          cat <<EOF | kubectl apply -f -
          apiVersion: chaos-mesh.org/v1alpha1
          kind: PodChaos
          metadata:
            name: ci-pod-kill-$(date +%s)
            namespace: chaos-engineering
          spec:
            action: pod-kill
            mode: fixed
            value: "1"
            selector:
              namespaces:
                - $TARGET_NAMESPACE
              labelSelectors:
                app: auth-service
            duration: 30s
          EOF
          
          echo "ðŸ§ª Pod kill experiment started"

      - name: Monitor pod recovery
        timeout-minutes: 5
        run: |
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          echo "Monitoring pod recovery..."
          
          # Wait for pods to be killed and recreated
          sleep 10
          
          # Check that pods are recovering
          for i in {1..10}; do
            READY_PODS=$(kubectl get pods -n "$TARGET_NAMESPACE" -l app=auth-service --no-headers | grep "Running" | wc -l)
            DESIRED_PODS=$(kubectl get deployment -n "$TARGET_NAMESPACE" auth-service -o jsonpath='{.spec.replicas}')
            
            echo "Ready pods: $READY_PODS, Desired: $DESIRED_PODS"
            
            if [[ "$READY_PODS" -eq "$DESIRED_PODS" ]]; then
              echo "âœ… Pod recovery successful"
              break
            fi
            
            sleep 15
          done

  run-security-tests:
    name: Run Security Attack Simulations
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, install-chaos-mesh]
    if: |
      needs.pre-flight-checks.outputs.can_proceed == 'true' && 
      (github.event.inputs.experiment_type == 'security-tests' || 
       github.event.inputs.experiment_type == 'full-suite')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Build security testing suite
        run: |
          cd security-testing
          cargo build --release --bin security_e2e_suite

      - name: Get service endpoints
        id: endpoints
        run: |
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          # Get service endpoints
          if kubectl get service -n "$TARGET_NAMESPACE" auth-service >/dev/null 2>&1; then
            AUTH_SERVICE_URL="http://$(kubectl get service -n "$TARGET_NAMESPACE" auth-service -o jsonpath='{.spec.clusterIP}'):8080"
            echo "auth_service_url=$AUTH_SERVICE_URL" >> $GITHUB_OUTPUT
          else
            echo "auth_service_url=http://localhost:8080" >> $GITHUB_OUTPUT
          fi
          
          if kubectl get service -n "$TARGET_NAMESPACE" policy-service >/dev/null 2>&1; then
            POLICY_SERVICE_URL="http://$(kubectl get service -n "$TARGET_NAMESPACE" policy-service -o jsonpath='{.spec.clusterIP}'):8080"
            echo "policy_service_url=$POLICY_SERVICE_URL" >> $GITHUB_OUTPUT
          else
            echo "policy_service_url=http://localhost:8081" >> $GITHUB_OUTPUT
          fi

      - name: Run credential stuffing attack simulation
        run: |
          echo "ðŸ”’ Running credential stuffing attack simulation..."
          
          # Create test configuration
          cat > security_test_config.json <<EOF
          {
            "target_base_url": "${{ steps.endpoints.outputs.auth_service_url }}",
            "auth_service_url": "${{ steps.endpoints.outputs.auth_service_url }}",
            "policy_service_url": "${{ steps.endpoints.outputs.policy_service_url }}",
            "timeout_seconds": 30,
            "concurrent_requests": 5,
            "attack_duration_seconds": 180,
            "detection_timeout_seconds": 30,
            "valid_credentials": {
              "test_user": "test_password"
            },
            "test_environment": "${{ env.TARGET_ENV }}"
          }
          EOF
          
          # Run security tests with port forwarding
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          kubectl port-forward -n "$TARGET_NAMESPACE" svc/auth-service 8080:8080 &
          AUTH_PF_PID=$!
          kubectl port-forward -n "$TARGET_NAMESPACE" svc/policy-service 8081:8080 &
          POLICY_PF_PID=$!
          
          sleep 5
          
          # Run the actual security tests
          timeout 300s ./security-testing/target/release/security_e2e_suite --config security_test_config.json || echo "Security tests completed with some findings"
          
          # Cleanup port forwards
          kill $AUTH_PF_PID $POLICY_PF_PID 2>/dev/null || true

      - name: Collect security test results
        run: |
          echo "ðŸ“Š Collecting security test results..."
          
          # Check for any security test artifacts
          if [[ -f security_test_results.json ]]; then
            echo "Security test results found:"
            cat security_test_results.json
          else
            echo "No security test results file found"
          fi
          
          # Check application logs for security events
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          kubectl logs -n "$TARGET_NAMESPACE" -l app=auth-service --tail=50 | grep -i "attack\|security\|blocked" || echo "No security events found in auth-service logs"

  validate-resilience:
    name: Validate Resilience Patterns
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, run-network-chaos, run-pod-chaos]
    if: |
      always() && 
      needs.pre-flight-checks.outputs.can_proceed == 'true' &&
      (needs.run-network-chaos.result == 'success' || needs.run-pod-chaos.result == 'success')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup kubectl  
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Build resilience validator
        run: |
          cd chaos-engineering/framework
          cargo build --release --bin resilience_validator

      - name: Run resilience validation
        run: |
          echo "ðŸ” Running resilience validation..."
          
          # Create validation configuration
          cat > resilience_config.yaml <<EOF
          validation_window_minutes: 10
          baseline_collection_minutes: 5
          recovery_timeout_minutes: 5
          acceptable_degradation_percent: 20.0
          sla_requirements:
            availability_percent: 99.0
            response_time_p95_ms: 1000.0
            error_rate_percent: 1.0
            recovery_time_objective_minutes: 5.0
            recovery_point_objective_minutes: 1.0
          resilience_patterns:
            - name: "Circuit Breaker"
              description: "Circuit breaker pattern validation"
              pattern_type: "CircuitBreaker"
              validation_rules: []
              criticality: "High"
            - name: "Retry Pattern"
              description: "Retry pattern validation"
              pattern_type: "Retry"
              validation_rules: []
              criticality: "Medium"
          EOF
          
          # Run resilience validation
          timeout 600s ./chaos-engineering/framework/target/release/resilience_validator --config resilience_config.yaml --experiment-id "ci-experiment-$(date +%s)" || echo "Resilience validation completed"

      - name: Generate resilience report
        run: |
          echo "ðŸ“‹ Generating resilience report..."
          
          # Collect final system state
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          echo "## Resilience Validation Report" > resilience_report.md
          echo "**Generated:** $(date -u)" >> resilience_report.md
          echo "**Environment:** ${{ env.TARGET_ENV }}" >> resilience_report.md
          echo "" >> resilience_report.md
          
          echo "### System Status" >> resilience_report.md
          kubectl get pods -n "$TARGET_NAMESPACE" >> resilience_report.md
          echo "" >> resilience_report.md
          
          echo "### Recent Events" >> resilience_report.md
          kubectl get events -n "$TARGET_NAMESPACE" --sort-by='.lastTimestamp' | tail -10 >> resilience_report.md
          
          echo "âœ… Resilience report generated"

      - name: Upload resilience report
        uses: actions/upload-artifact@v4
        with:
          name: resilience-report-${{ env.TARGET_ENV }}
          path: resilience_report.md

  cleanup:
    name: Cleanup Experiments
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, run-network-chaos, run-pod-chaos, run-security-tests, validate-resilience]
    if: always() && needs.pre-flight-checks.outputs.can_proceed == 'true'
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > $KUBECONFIG
          chmod 600 $KUBECONFIG

      - name: Clean up chaos experiments
        run: |
          echo "ðŸ§¹ Cleaning up chaos experiments..."
          
          # Delete all chaos experiments from this CI run
          kubectl delete networkchaos -n chaos-engineering -l "app.kubernetes.io/managed-by=ci" --ignore-not-found=true
          kubectl delete podchaos -n chaos-engineering -l "app.kubernetes.io/managed-by=ci" --ignore-not-found=true
          kubectl delete stresschaos -n chaos-engineering -l "app.kubernetes.io/managed-by=ci" --ignore-not-found=true
          kubectl delete iochaos -n chaos-engineering -l "app.kubernetes.io/managed-by=ci" --ignore-not-found=true
          
          # Clean up any test pods
          kubectl delete pod curl-test -n default --ignore-not-found=true

      - name: Restore service replicas
        run: |
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          # Ensure services are back to normal replica counts
          kubectl scale deployment -n "$TARGET_NAMESPACE" auth-service --replicas=1 2>/dev/null || true
          kubectl scale deployment -n "$TARGET_NAMESPACE" policy-service --replicas=1 2>/dev/null || true

      - name: Final health check
        run: |
          TARGET_NAMESPACE="rust-security-${{ env.TARGET_ENV }}"
          
          echo "ðŸ¥ Performing final health check..."
          
          # Wait for services to be ready
          kubectl wait --for=condition=available deployment/auth-service -n "$TARGET_NAMESPACE" --timeout=120s
          kubectl wait --for=condition=available deployment/policy-service -n "$TARGET_NAMESPACE" --timeout=120s
          
          # Verify all pods are running
          NOT_RUNNING=$(kubectl get pods -n "$TARGET_NAMESPACE" --no-headers | grep -v "Running\|Completed" | wc -l)
          if [[ "$NOT_RUNNING" -gt 0 ]]; then
            echo "âš ï¸ Warning: $NOT_RUNNING pods are not in running state"
            kubectl get pods -n "$TARGET_NAMESPACE"
          else
            echo "âœ… All services healthy after cleanup"
          fi

  report:
    name: Generate Final Report
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, run-network-chaos, run-pod-chaos, run-security-tests, validate-resilience, cleanup]
    if: always() && needs.pre-flight-checks.outputs.can_proceed == 'true'
    
    steps:
      - name: Generate comprehensive report
        run: |
          echo "ðŸ“Š Generating comprehensive chaos engineering report..."
          
          cat > chaos_engineering_report.md <<EOF
          # Chaos Engineering & Security Testing Report
          
          **Date:** $(date -u)
          **Environment:** ${{ env.TARGET_ENV }}
          **Triggered by:** ${{ github.event_name }}
          **Duration:** ${{ env.EXPERIMENT_DURATION }} minutes
          
          ## Summary
          
          | Component | Status |
          |-----------|--------|
          | Pre-flight Checks | ${{ needs.pre-flight-checks.result }} |
          | Network Chaos | ${{ needs.run-network-chaos.result }} |
          | Pod Chaos | ${{ needs.run-pod-chaos.result }} |
          | Security Tests | ${{ needs.run-security-tests.result }} |
          | Resilience Validation | ${{ needs.validate-resilience.result }} |
          | Cleanup | ${{ needs.cleanup.result }} |
          
          ## Baseline Metrics
          \`\`\`json
          ${{ needs.pre-flight-checks.outputs.baseline_metrics }}
          \`\`\`
          
          ## Recommendations
          
          Based on the experiments conducted:
          
          1. **Network Resilience**: Monitor network latency impact on service performance
          2. **Pod Recovery**: Validate auto-scaling and health check configurations  
          3. **Security Posture**: Review security controls based on attack simulations
          4. **Monitoring**: Ensure alerts are configured for detected anomalies
          
          ## Next Steps
          
          - Review detailed logs in workflow artifacts
          - Update resilience patterns based on findings
          - Schedule regular chaos engineering exercises
          - Implement any recommended security improvements
          
          ---
          *Generated by Rust Security Platform Chaos Engineering Suite*
          EOF
          
          echo "âœ… Comprehensive report generated"

      - name: Upload final report
        uses: actions/upload-artifact@v4
        with:
          name: chaos-engineering-report-${{ github.run_number }}
          path: chaos_engineering_report.md

      - name: Notify results
        if: failure()
        run: |
          echo "ðŸš¨ Chaos Engineering workflow failed!"
          echo "Check the logs and artifacts for detailed information."
          
          # In a real environment, you would send notifications to:
          # - Slack/Teams channels
          # - Email notifications
          # - PagerDuty/Opsgenie alerts
          # - Dashboard updates

      - name: Success notification
        if: success()
        run: |
          echo "âœ… Chaos Engineering and Security Testing completed successfully!"
          echo "All experiments executed and system resilience validated."
