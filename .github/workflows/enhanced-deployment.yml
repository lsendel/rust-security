name: Enhanced Deployment Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip testing phase'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  actions: read
  security-events: write
  id-token: write
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  CARGO_TERM_COLOR: always
  RUST_VERSION: stable

jobs:
  # Pre-deployment validation
  pre-deployment:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      version: ${{ steps.version.outputs.version }}
      environment: ${{ steps.environment.outputs.environment }}
      deploy: ${{ steps.validation.outputs.deploy }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          else
            VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev-$(date +%Y%m%d-%H%M%S)")
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Determine environment
        id: environment
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ $GITHUB_REF == refs/tags/v* ]]; then
            ENV="production"
          else
            ENV="staging"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "Environment: $ENV"

      - name: Validate deployment conditions
        id: validation
        run: |
          DEPLOY="true"
          
          # Check if we should deploy
          if [ "${{ github.event_name }}" = "push" ] && [ "$GITHUB_REF" != "refs/heads/main" ] && [[ $GITHUB_REF != refs/tags/v* ]]; then
            DEPLOY="false"
            echo "Skipping deployment for non-main branch"
          fi
          
          # Check for security vulnerabilities
          if cargo audit --json > audit.json 2>/dev/null; then
            HIGH_VULNS=$(jq '.vulnerabilities.found | length' audit.json)
            if [ "$HIGH_VULNS" -gt 0 ]; then
              echo "Security vulnerabilities found, deployment blocked"
              DEPLOY="false"
            fi
          fi
          
          echo "deploy=$DEPLOY" >> $GITHUB_OUTPUT
          echo "Deploy: $DEPLOY"

  # Build and test (can be skipped for hotfixes)
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: needs.pre-deployment.outputs.deploy == 'true' && !inputs.skip_tests
    timeout-minutes: 30
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U test_user -d test_db"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          key: deployment-${{ hashFiles('**/Cargo.lock') }}

      - name: Run security checks
        run: |
          echo "🔒 Running security checks..."
          cargo install cargo-audit --locked
          cargo audit
          
          echo "📋 Checking licenses..."
          cargo install cargo-license --locked
          cargo license --json > licenses.json
          
          # Check for forbidden licenses
          FORBIDDEN_LICENSES=("GPL-3.0" "AGPL-3.0")
          for license in "${FORBIDDEN_LICENSES[@]}"; do
            if jq -r '.[].license' licenses.json | grep -q "$license"; then
              echo "❌ Forbidden license found: $license"
              exit 1
            fi
          done

      - name: Build release artifacts
        run: |
          echo "🔨 Building release artifacts..."
          cargo build --release --workspace --all-features
          
          # Verify binaries exist
          for binary in auth-service policy-service; do
            if [ -f "target/release/$binary" ]; then
              echo "✅ Built: $binary"
              ls -la "target/release/$binary"
            else
              echo "⚠️  Binary not found: $binary"
            fi
          done

      - name: Run comprehensive tests
        env:
          DATABASE_URL: postgres://test_user:test_password@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379
        run: |
          echo "🧪 Running comprehensive tests..."
          cargo test --release --workspace --all-features

      - name: Package artifacts
        run: |
          echo "📦 Packaging artifacts..."
          mkdir -p artifacts
          
          # Copy binaries if they exist
          for binary in auth-service policy-service; do
            if [ -f "target/release/$binary" ]; then
              cp "target/release/$binary" "artifacts/"
            fi
          done
          
          # Copy configuration files
          cp -r deployment/ artifacts/ || echo "No deployment configs found"
          cp -r docs/ artifacts/ || echo "No docs found"
          
          # Create version file
          echo "${{ needs.pre-deployment.outputs.version }}" > artifacts/VERSION

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ needs.pre-deployment.outputs.version }}
          path: artifacts/
          retention-days: 30

  # Container build and security scan
  container-build:
    name: Container Build & Scan
    runs-on: ubuntu-latest
    needs: [pre-deployment, build-and-test]
    if: needs.pre-deployment.outputs.deploy == 'true' && (success() || inputs.skip_tests)
    timeout-minutes: 25
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build artifacts
        if: ${{ !inputs.skip_tests }}
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ needs.pre-deployment.outputs.version }}
          path: artifacts/

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=${{ needs.pre-deployment.outputs.version }}

      - name: Build and push container images
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: deployment/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.pre-deployment.outputs.version }}
            BUILD_DATE=${{ steps.meta.outputs.created }}

      - name: Sign container image
        run: |
          echo "✍️ Signing container image..."
          # Install cosign
          curl -sL https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64 -o cosign
          chmod +x cosign
          sudo mv cosign /usr/local/bin/
          
          # Sign the image
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}

      - name: Generate SBOM
        run: |
          echo "📋 Generating SBOM..."
          # Install syft
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          
          # Generate SBOM
          syft ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }} -o spdx-json > sbom.json

      - name: Scan container for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload container scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ needs.pre-deployment.outputs.version }}
          path: sbom.json
          retention-days: 90

  # Deploy to staging/production
  deploy:
    name: Deploy to ${{ needs.pre-deployment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [pre-deployment, container-build]
    if: needs.pre-deployment.outputs.deploy == 'true'
    timeout-minutes: 20
    environment: ${{ needs.pre-deployment.outputs.environment }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure AWS credentials
        if: contains(github.repository, 'aws')
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Update Kubernetes manifests
        run: |
          echo "📝 Updating Kubernetes manifests..."
          
          # Update image references
          IMAGE_WITH_DIGEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.container-build.outputs.image-digest }}"
          
          sed -i "s|image: .*auth-service.*|image: $IMAGE_WITH_DIGEST|g" deployment/kubernetes.yaml
          sed -i "s|image: .*policy-service.*|image: $IMAGE_WITH_DIGEST|g" deployment/kubernetes.yaml
          
          # Update version labels
          sed -i "s/version: .*/version: \"${{ needs.pre-deployment.outputs.version }}\"/g" deployment/kubernetes.yaml

      - name: Deploy to Kubernetes
        run: |
          echo "🚀 Deploying to ${{ needs.pre-deployment.outputs.environment }}..."
          
          # Apply configuration
          kubectl apply -f deployment/kubernetes.yaml
          
          # Wait for rollout
          kubectl rollout status deployment/auth-service -n auth-system --timeout=300s
          kubectl rollout status deployment/policy-service -n auth-system --timeout=300s || echo "Policy service rollout check failed"
          
          # Verify deployment
          kubectl get pods -n auth-system
          kubectl get services -n auth-system

      - name: Run health checks
        run: |
          echo "🏥 Running health checks..."
          
          # Wait for services to be ready
          sleep 30
          
          # Get service endpoints
          AUTH_SERVICE_URL=$(kubectl get service auth-service-lb -n auth-system -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "localhost:8080")
          
          # Health check with retries
          for i in {1..10}; do
            if curl -f -s "http://$AUTH_SERVICE_URL/health" > /dev/null; then
              echo "✅ Auth service health check passed"
              break
            else
              echo "⏳ Health check attempt $i/10 failed, retrying in 10s..."
              sleep 10
            fi
          done

      - name: Run deployment validation
        run: |
          echo "✅ Running deployment validation..."
          
          # Run validation scripts if they exist
          for script in scripts/validation/*.sh; do
            if [ -f "$script" ]; then
              echo "Running validation: $(basename "$script")"
              timeout 60s bash "$script" || echo "Validation $(basename "$script") failed"
            fi
          done

  # Post-deployment monitoring setup
  post-deployment:
    name: Post-deployment Setup
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy]
    if: success()
    timeout-minutes: 10
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup monitoring alerts
        run: |
          echo "📊 Setting up monitoring alerts..."
          
          # Deploy monitoring configurations
          if [ -f "deployment/monitoring/alerts.yaml" ]; then
            kubectl apply -f deployment/monitoring/alerts.yaml || echo "Alert configuration failed"
          fi
          
          # Update dashboards
          if [ -d "deployment/monitoring/dashboards/" ]; then
            kubectl create configmap grafana-dashboards --from-file=deployment/monitoring/dashboards/ -o yaml --dry-run=client | kubectl apply -f - || echo "Dashboard update failed"
          fi

      - name: Run performance baseline
        run: |
          echo "📈 Establishing performance baseline..."
          
          # Run performance tests against deployed service
          if [ -f "scripts/performance/baseline-check.sh" ]; then
            timeout 300s bash scripts/performance/baseline-check.sh || echo "Performance baseline failed"
          fi

      - name: Update deployment status
        run: |
          echo "📋 Updating deployment status..."
          
          # Create deployment record
          cat > deployment-record.json << EOF
          {
            "version": "${{ needs.pre-deployment.outputs.version }}",
            "environment": "${{ needs.pre-deployment.outputs.environment }}",
            "timestamp": "$(date -Iseconds)",
            "commit": "${{ github.sha }}",
            "actor": "${{ github.actor }}",
            "workflow_run": "${{ github.run_id }}"
          }
          EOF
          
          echo "Deployment completed successfully!"

      - name: Notify deployment
        if: always()
        run: |
          echo "📢 Sending deployment notifications..."
          
          STATUS="${{ job.status }}"
          if [ "$STATUS" = "success" ]; then
            EMOJI="✅"
            COLOR="good"
          else
            EMOJI="❌"
            COLOR="danger"
          fi
          
          MESSAGE="$EMOJI Deployment to ${{ needs.pre-deployment.outputs.environment }} $STATUS"
          MESSAGE="$MESSAGE\nVersion: ${{ needs.pre-deployment.outputs.version }}"
          MESSAGE="$MESSAGE\nCommit: ${{ github.sha }}"
          MESSAGE="$MESSAGE\nActor: ${{ github.actor }}"
          
          echo "$MESSAGE"
          # Add Slack/Teams notification here if configured

  # Rollback capability
  rollback:
    name: Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && needs.deploy.result == 'failure'
    needs: [pre-deployment, deploy]
    timeout-minutes: 10
    environment: ${{ needs.pre-deployment.outputs.environment }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Rollback deployment
        run: |
          echo "🔄 Initiating emergency rollback..."
          
          # Rollback to previous revision
          kubectl rollout undo deployment/auth-service -n auth-system
          kubectl rollout undo deployment/policy-service -n auth-system || echo "Policy service rollback failed"
          
          # Wait for rollback to complete
          kubectl rollout status deployment/auth-service -n auth-system --timeout=300s
          
          # Verify rollback
          kubectl get pods -n auth-system
          
          echo "🔄 Rollback completed"

      - name: Notify rollback
        if: always()
        run: |
          echo "📢 Rollback notification"
          echo "❌ Deployment failed and was rolled back"
          echo "Environment: ${{ needs.pre-deployment.outputs.environment }}"
          echo "Version attempted: ${{ needs.pre-deployment.outputs.version }}"