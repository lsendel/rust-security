//! Security-focused tests for auth-core
//!
//! Comprehensive security testing including:
//! - Timing attack resistance
//! - Token security and randomness
//! - Input validation and sanitization
//! - Rate limiting and abuse prevention

/* Security tests temporarily disabled
use auth_core::prelude::*;
use std::collections::HashMap;
use std::time::{Duration, Instant};

#[tokio::test]
async fn test_timing_attack_resistance_client_validation() {
    // Test that client secret validation is resistant to timing attacks
    let server = AuthServer::minimal()
        .with_client("test_client", "correct_secret_that_is_long")
        .build()
        .expect("Failed to build server");

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    let server_handle = tokio::spawn(async move {
        axum::serve(listener, server.into_make_service()).await.unwrap();
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let client = reqwest::Client::new();

    // Measure time for completely wrong secret
    let wrong_secret = "wrong_secret_that_is_long";
    let start = Instant::now();
    for _ in 0..10 {
        let _ = client
            .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
            .form(&[
                ("grant_type", "client_credentials"),
                ("client_id", "test_client"),
                ("client_secret", wrong_secret),
            ])
            .send()
            .await;
    }
    let wrong_duration = start.elapsed();

    // Measure time for partially correct secret (same length)
    let partial_secret = "correct_secret_that_is_wron"; // Same length, mostly correct
    let start = Instant::now();
    for _ in 0..10 {
        let _ = client
            .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
            .form(&[
                ("grant_type", "client_credentials"),
                ("client_id", "test_client"),
                ("client_secret", partial_secret),
            ])
            .send()
            .await;
    }
    let partial_duration = start.elapsed();

    // The timing difference should be minimal (within reasonable bounds)
    // Allow for up to 50% timing variation to account for network/system jitter
    let timing_ratio = if wrong_duration > partial_duration {
        wrong_duration.as_nanos() as f64 / partial_duration.as_nanos() as f64
    } else {
        partial_duration.as_nanos() as f64 / wrong_duration.as_nanos() as f64
    };

    // Both should take roughly the same time (timing-safe comparison)
    assert!(timing_ratio < 1.5, "Timing attack vulnerability detected! Ratio: {:.2}", timing_ratio);

    server_handle.abort();
}

#[tokio::test]
async fn test_token_randomness_and_uniqueness() {
    let server = AuthServer::minimal()
        .with_client("test_client", "test_secret")
        .build()
        .expect("Failed to build server");

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    let server_handle = tokio::spawn(async move {
        axum::serve(listener, server.into_make_service()).await.unwrap();
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let client = reqwest::Client::new();

    let mut tokens = std::collections::HashSet::new();

    // Generate 100 tokens and ensure they're all unique
    for _ in 0..100 {
        let response = client
            .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
            .form(&[
                ("grant_type", "client_credentials"),
                ("client_id", "test_client"),
                ("client_secret", "test_secret"),
            ])
            .send()
            .await
            .expect("Failed to get token");

        let token_data: serde_json::Value = response.json().await.unwrap();
        let access_token = token_data.get("access_token").unwrap().as_str().unwrap();

        // Verify token format
        assert!(access_token.starts_with("auth_core_"));
        assert!(access_token.len() > 40); // Should be reasonably long

        // Verify uniqueness
        assert!(!tokens.contains(access_token), "Duplicate token generated: {}", access_token);
        tokens.insert(access_token.to_string());
    }

    // Test token entropy by checking character distribution
    let all_tokens = tokens.iter().collect::<Vec<_>>();
    let combined_tokens = all_tokens.join("");

    // Count character frequency (should be reasonably distributed)
    let mut char_counts = std::collections::HashMap::new();
    for c in combined_tokens.chars() {
        if c.is_alphanumeric() {
            *char_counts.entry(c).or_insert(0) += 1;
        }
    }

    // Basic entropy check - no single character should dominate
    let total_chars = combined_tokens.len() as f64;
    for (_, count) in char_counts {
        let frequency = count as f64 / total_chars;
        assert!(
            frequency < 0.05, // No character should be > 5% of total
            "Poor randomness detected - character frequency too high: {:.2}%",
            frequency * 100.0
        );
    }

    server_handle.abort();
}

#[tokio::test]
async fn test_input_validation_and_sanitization() {
    let server = AuthServer::minimal()
        .with_client("valid_client", "valid_secret")
        .build()
        .expect("Failed to build server");

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    let server_handle = tokio::spawn(async move {
        axum::serve(listener, server.into_make_service()).await.unwrap();
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let client = reqwest::Client::new();

    // Test various malicious inputs
    let malicious_inputs = vec![
        ("", ""),                                       // Empty strings
        ("../../../etc/passwd", "secret"),              // Path traversal
        ("<script>alert('xss')</script>", "secret"),    // XSS
        ("client'; DROP TABLE clients; --", "secret"),  // SQL injection
        ("client\x00null_byte", "secret"),              // Null byte injection
        ("client\r\nHeader-Injection: evil", "secret"), // Header injection
        ("client".repeat(1000).as_str(), "secret"),     // Extremely long input
        ("valid_client", "secret\x00with_null"),        // Null bytes in password
    ];

    for (client_id, client_secret) in malicious_inputs {
        let response = client
            .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
            .form(&[
                ("grant_type", "client_credentials"),
                ("client_id", client_id),
                ("client_secret", client_secret),
            ])
            .send()
            .await
            .expect("Failed to send request");

        // Should return 400 or 401, never 500 (server error)
        assert!(
            response.status().as_u16() < 500,
            "Server error with input: client_id='{}', status={}",
            client_id,
            response.status()
        );

        // Should be proper error response
        if response.status() != 401 {
            let response_text = response.text().await.unwrap_or_default();
            // Should be valid JSON error response
            let _: Result<serde_json::Value, _> = serde_json::from_str(&response_text);
        }
    }

    server_handle.abort();
}

#[tokio::test]
async fn test_scope_validation_and_sanitization() {
    let server = AuthServer::minimal()
        .with_client("test_client", "test_secret")
        .with_scope("read")
        .with_scope("write")
        .build()
        .expect("Failed to build server");

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    let server_handle = tokio::spawn(async move {
        axum::serve(listener, server.into_make_service()).await.unwrap();
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let client = reqwest::Client::new();

    // Test malicious scope values
    let malicious_scopes = vec![
        "../../../etc/passwd",
        "<script>alert('xss')</script>",
        "read'; DROP TABLE tokens; --",
        "scope\x00with_null",
        "scope\r\nwith_newlines",
        &"very_long_scope_".repeat(1000),
        "read write admin root system", // Scope escalation attempt
    ];

    for scope in malicious_scopes {
        let response = client
            .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
            .form(&[
                ("grant_type", "client_credentials"),
                ("client_id", "test_client"),
                ("client_secret", "test_secret"),
                ("scope", scope),
            ])
            .send()
            .await
            .expect("Failed to send request");

        // Should handle gracefully, not crash
        assert!(
            response.status().as_u16() < 500,
            "Server error with scope: '{}', status={}",
            scope,
            response.status()
        );
    }

    server_handle.abort();
}

#[tokio::test]
async fn test_token_storage_security() {
    // Test that tokens are not leaked in logs or error messages
    let server = AuthServer::minimal()
        .with_client("test_client", "test_secret")
        .build()
        .expect("Failed to build server");

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    let server_handle = tokio::spawn(async move {
        axum::serve(listener, server.into_make_service()).await.unwrap();
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let client = reqwest::Client::new();

    // Get a valid token
    let token_response = client
        .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
        .form(&[
            ("grant_type", "client_credentials"),
            ("client_id", "test_client"),
            ("client_secret", "test_secret"),
        ])
        .send()
        .await
        .expect("Failed to get token");

    let token_data: serde_json::Value = token_response.json().await.unwrap();
    let access_token = token_data.get("access_token").unwrap().as_str().unwrap();

    // Try to trigger error responses that might leak token data
    let error_requests = vec![
        // Invalid endpoints with token in various positions
        (format!("http://127.0.0.1:{}/oauth/invalid?token={}", addr.port(), access_token), "GET"),
        (format!("http://127.0.0.1:{}/oauth/token", addr.port()), "POST"), // Malformed request
    ];

    for (url, method) in error_requests {
        let response = if method == "GET" {
            client.get(&url).send().await
        } else {
            client.post(&url)
                .form(&[("invalid", access_token)]) // Token in wrong field
                .send().await
        };

        if let Ok(resp) = response {
            if let Ok(body) = resp.text().await {
                // Token should never appear in error responses
                assert!(!body.contains(access_token), "Token leaked in error response: {}", body);
                assert!(
                    !body.to_lowercase().contains("auth_core_"),
                    "Token prefix leaked in error response: {}",
                    body
                );
            }
        }
    }

    server_handle.abort();
}

#[tokio::test]
async fn test_concurrent_access_safety() {
    // Test thread safety and concurrent access patterns
    let server = AuthServer::minimal()
        .with_client("test_client", "test_secret")
        .build()
        .expect("Failed to build server");

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    let server_handle = tokio::spawn(async move {
        axum::serve(listener, server.into_make_service()).await.unwrap();
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    // Spawn multiple concurrent requests
    let mut handles = Vec::new();
    for i in 0..50 {
        let addr = addr;
        let handle = tokio::spawn(async move {
            let client = reqwest::Client::new();

            let response = client
                .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
                .form(&[
                    ("grant_type", "client_credentials"),
                    ("client_id", "test_client"),
                    ("client_secret", "test_secret"),
                    ("scope", &format!("test_{}", i)), // Unique scope per request
                ])
                .send()
                .await;

            match response {
                Ok(resp) if resp.status() == 200 => {
                    // Successful response
                    resp.json::<serde_json::Value>().await.ok()
                }
                _ => None,
            }
        });
        handles.push(handle);
    }

    // Wait for all requests to complete
    let results = futures::future::join_all(handles).await;

    // Count successful responses
    let mut successful_tokens = std::collections::HashSet::new();
    let mut success_count = 0;

    for result in results {
        if let Ok(Some(token_data)) = result {
            if let Some(token) = token_data.get("access_token") {
                if let Some(token_str) = token.as_str() {
                    assert!(
                        !successful_tokens.contains(token_str),
                        "Duplicate token in concurrent access: {}",
                        token_str
                    );
                    successful_tokens.insert(token_str.to_string());
                    success_count += 1;
                }
            }
        }
    }

    // Should handle concurrent requests successfully
    assert!(
        success_count > 40,
        "Too many failed concurrent requests: {}/50 successful",
        success_count
    );

    server_handle.abort();
}

#[tokio::test]
async fn test_memory_exhaustion_protection() {
    // Test protection against memory exhaustion attacks
    let server = AuthServer::minimal()
        .with_client("test_client", "test_secret")
        .build()
        .expect("Failed to build server");

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    let server_handle = tokio::spawn(async move {
        axum::serve(listener, server.into_make_service()).await.unwrap();
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let client = reqwest::Client::new();

    // Try to send extremely large payloads
    let large_string = "x".repeat(1024 * 1024); // 1MB string

    let response = client
        .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
        .form(&[
            ("grant_type", "client_credentials"),
            ("client_id", &large_string),
            ("client_secret", &large_string),
            ("scope", &large_string),
        ])
        .send()
        .await;

    // Should either reject the request or handle it gracefully
    match response {
        Ok(resp) => {
            assert!(
                resp.status().as_u16() < 500,
                "Server crashed with large payload: status={}",
                resp.status()
            );
        }
        Err(e) => {
            // Connection error is acceptable - server may reject large payloads
            println!("Large payload rejected (expected): {}", e);
        }
    }

    server_handle.abort();
}

#[cfg(feature = "rate-limiting")]
#[tokio::test]
async fn test_rate_limiting_protection() {
    // Test rate limiting to prevent brute force attacks
    let server = AuthServer::minimal()
        .with_client("test_client", "test_secret")
        .with_rate_limit(5, 60) // 5 requests per minute
        .build()
        .expect("Failed to build server");

    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    let server_handle = tokio::spawn(async move {
        axum::serve(listener, server.into_make_service()).await.unwrap();
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

    let client = reqwest::Client::new();
    let mut success_count = 0;
    let mut rate_limited_count = 0;

    // Send requests rapidly
    for i in 0..10 {
        let response = client
            .post(format!("http://127.0.0.1:{}/oauth/token", addr.port()))
            .form(&[
                ("grant_type", "client_credentials"),
                ("client_id", "test_client"),
                ("client_secret", "wrong_secret"), // Intentionally wrong to trigger rate limiting
            ])
            .send()
            .await
            .expect("Failed to send request");

        match response.status().as_u16() {
            429 => rate_limited_count += 1, // Too Many Requests
            401 => success_count += 1,      // Unauthorized (expected for wrong secret)
            _ => {}
        }
    }

    // Should have triggered rate limiting
    assert!(
        rate_limited_count > 0,
        "Rate limiting not triggered: {} rate limited, {} unauthorized",
        rate_limited_count,
        success_count
    );

    server_handle.abort();
}
*/
